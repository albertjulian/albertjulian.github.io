"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(require("react"));
var classnames_1 = __importDefault(require("classnames"));
var noop_1 = __importDefault(require("lodash/fp/noop"));
var omit_1 = __importDefault(require("lodash/fp/omit"));
var range_1 = __importDefault(require("lodash/fp/range"));
var mvu_1 = __importDefault(require("../mvu"));
var kb_event_1 = require("../kb-event");
exports.NO_EFFECT = [];
exports.PROP_KEYS = ["autoFocus", "className", "length", "validate", "format", "style"];
exports.HANDLER_KEYS = ["onResolveKey", "onRejectKey", "onChange", "onComplete"];
exports.IGNORED_META_KEYS = ["Alt", "Control", "Enter", "Meta", "Shift", "Tab"];
exports.defaultProps = {
    ref: { current: [] },
    className: "",
    length: 5,
    validate: /^[a-zA-Z0-9]$/,
    format: function (key) { return key; },
    onResolveKey: noop_1.default,
    onRejectKey: noop_1.default,
    onChange: noop_1.default,
    onComplete: noop_1.default,
    style: {},
};
function defaultState(props) {
    return {
        focusIdx: 0,
        codeLength: props.length,
        isKeyAllowed: isKeyAllowed(props.validate),
    };
}
exports.defaultState = defaultState;
function getPrevFocusIdx(currFocusIdx) {
    return Math.max(0, currFocusIdx - 1);
}
exports.getPrevFocusIdx = getPrevFocusIdx;
function getNextFocusIdx(currFocusIdx, lastFocusIdx) {
    if (lastFocusIdx === 0)
        return 0;
    return Math.min(currFocusIdx + 1, lastFocusIdx - 1);
}
exports.getNextFocusIdx = getNextFocusIdx;
function isKeyAllowed(predicate) {
    return function (key) {
        if (!key)
            return false;
        if (key.length > 1)
            return false;
        if (typeof predicate === "string")
            return predicate.split("").includes(key);
        if (predicate instanceof Array)
            return predicate.includes(key);
        if (predicate instanceof RegExp)
            return predicate.test(key);
        return predicate(key);
    };
}
exports.isKeyAllowed = isKeyAllowed;
function apply(state, action) {
    switch (action.type) {
        case "handle-key-down": {
            switch (action.key) {
                case "Unidentified":
                case "Dead": {
                    var effects = [
                        { type: "set-input-val", idx: state.focusIdx, val: "" },
                        { type: "reject-key", idx: state.focusIdx, key: action.key },
                        { type: "handle-code-change" },
                    ];
                    return [state, effects];
                }
                case "ArrowLeft": {
                    var prevFocusIdx = getPrevFocusIdx(state.focusIdx);
                    var effects = [{ type: "focus-input", idx: prevFocusIdx }];
                    return [__assign(__assign({}, state), { focusIdx: prevFocusIdx }), effects];
                }
                case "ArrowRight": {
                    var nextFocusIdx = getNextFocusIdx(state.focusIdx, state.codeLength);
                    var effects = [{ type: "focus-input", idx: nextFocusIdx }];
                    return [__assign(__assign({}, state), { focusIdx: nextFocusIdx }), effects];
                }
                case "Delete":
                case "Backspace": {
                    var effects = [
                        { type: "handle-delete", idx: state.focusIdx },
                        { type: "handle-code-change" },
                    ];
                    return [state, effects];
                }
                default: {
                    if (state.isKeyAllowed(action.key)) {
                        var nextFocusIdx = getNextFocusIdx(state.focusIdx, state.codeLength);
                        var effects_1 = [
                            { type: "set-input-val", idx: state.focusIdx, val: action.key },
                            { type: "resolve-key", idx: state.focusIdx, key: action.key },
                            { type: "focus-input", idx: nextFocusIdx },
                            { type: "handle-code-change" },
                        ];
                        return [__assign(__assign({}, state), { focusIdx: nextFocusIdx }), effects_1];
                    }
                    var effects = [{ type: "reject-key", idx: state.focusIdx, key: action.key }];
                    return [state, effects];
                }
            }
        }
        case "handle-paste": {
            if (!action.val.split("").every(state.isKeyAllowed))
                return [state, exports.NO_EFFECT];
            var pasteLen = Math.min(action.val.length, state.codeLength - state.focusIdx);
            var nextFocusIdx = getNextFocusIdx(pasteLen + state.focusIdx - 1, state.codeLength);
            var effects = range_1.default(0, pasteLen).map(function (idx) { return ({
                type: "set-input-val",
                idx: idx + state.focusIdx,
                val: action.val[idx],
            }); });
            if (state.focusIdx !== nextFocusIdx) {
                effects.push({ type: "focus-input", idx: nextFocusIdx });
            }
            effects.push({ type: "handle-code-change" });
            return [__assign(__assign({}, state), { focusIdx: nextFocusIdx }), effects];
        }
        case "focus-input": {
            var effects = [{ type: "focus-input", idx: action.idx }];
            return [__assign(__assign({}, state), { focusIdx: action.idx }), effects];
        }
        default:
            return [state, exports.NO_EFFECT];
    }
}
exports.apply = apply;
function useNotifier(_a) {
    var refs = _a.refs, props = __rest(_a, ["refs"]);
    return react_1.useCallback(function (eff) {
        switch (eff.type) {
            case "focus-input":
                refs.current[eff.idx].focus();
                refs.current.forEach(function (input) { return input.classList.remove("-focus"); });
                refs.current[eff.idx].classList.add("-focus");
                break;
            case "set-input-val": {
                var val = props.format(eff.val);
                refs.current[eff.idx].value = val;
                if (val === "")
                    refs.current[eff.idx].classList.remove("-success");
                break;
            }
            case "resolve-key":
                refs.current[eff.idx].classList.remove("-error");
                refs.current[eff.idx].classList.add("-success");
                props.onResolveKey(eff.key, refs.current[eff.idx]);
                break;
            case "reject-key":
                refs.current[eff.idx].classList.remove("-success");
                refs.current[eff.idx].classList.add("-error");
                props.onRejectKey(eff.key, refs.current[eff.idx]);
                break;
            case "handle-delete": {
                var prevVal = refs.current[eff.idx].value;
                refs.current[eff.idx].classList.remove("-error", "-success");
                refs.current[eff.idx].value = "";
                if (!prevVal) {
                    var prevIdx = getPrevFocusIdx(eff.idx);
                    refs.current[prevIdx].focus();
                    refs.current[prevIdx].classList.remove("-error", "-success");
                    refs.current[prevIdx].value = "";
                }
                break;
            }
            case "handle-code-change": {
                var dir = (document.documentElement.getAttribute("dir") || "ltr").toLowerCase();
                var codeArr = refs.current.map(function (r) { return r.value.trim(); });
                var code = (dir === "rtl" ? codeArr.reverse() : codeArr).join("");
                props.onChange(code);
                code.length === props.length && props.onComplete(code);
                break;
            }
            default:
                break;
        }
    }, [props, refs]);
}
exports.useNotifier = useNotifier;
exports.PinField = react_1.forwardRef(function (customProps, fwdRef) {
    var props = __assign(__assign({}, exports.defaultProps), customProps);
    var autoFocus = props.autoFocus, className = props.className, codeLength = props.length, style = props.style;
    var inputProps = omit_1.default(__spreadArrays(exports.PROP_KEYS, exports.HANDLER_KEYS), props);
    var refs = react_1.useRef([]);
    var model = defaultState(props);
    var notify = useNotifier(__assign({ refs: refs }, props));
    var dispatch = mvu_1.default(model, apply, notify);
    react_1.useImperativeHandle(fwdRef, function () { return refs.current; }, [refs]);
    function setRefAtIndex(idx) {
        return function (ref) {
            if (ref) {
                refs.current[idx] = ref;
            }
        };
    }
    function handleFocus(idx) {
        return function () { return dispatch({ type: "focus-input", idx: idx }); };
    }
    function handleKeyDown(evt) {
        var key = kb_event_1.getKeyFromKeyboardEvent(evt.nativeEvent);
        if (!exports.IGNORED_META_KEYS.includes(key) && !evt.ctrlKey && !evt.altKey && !evt.metaKey) {
            evt.preventDefault();
            dispatch({ type: "handle-key-down", key: key });
        }
    }
    function handleInput(evt) {
        var key = kb_event_1.getKeyFromInputEvent(evt.nativeEvent);
        if (!exports.IGNORED_META_KEYS.includes(key)) {
            evt.preventDefault();
            dispatch({ type: "handle-key-down", key: key });
        }
    }
    function handlePaste(evt) {
        evt.preventDefault();
        dispatch({ type: "handle-paste", val: evt.clipboardData.getData("Text") });
    }
    function hasAutoFocus(idx) {
        return Boolean(idx === 0 && autoFocus);
    }
    return (react_1.default.createElement(react_1.default.Fragment, null, range_1.default(0, codeLength).map(function (idx) { return (react_1.default.createElement("input", __assign({ type: "text" }, inputProps, { key: idx, ref: setRefAtIndex(idx), className: classnames_1.default(className, "a-reactPinField__input", "-" + idx, {
            "-focus": hasAutoFocus(idx),
        }), autoFocus: hasAutoFocus(idx), maxLength: 1, onFocus: handleFocus(idx), onKeyDown: handleKeyDown, onInput: handleInput, onPaste: handlePaste, style: style }))); })));
});
exports.default = exports.PinField;
//# sourceMappingURL=pin-field.js.map